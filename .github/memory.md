# Memory

## Decisions & Context

- **electron-vite v5** uses Vite 7.3. Config file: `electron.vite.config.ts`. Three build targets: main, preload, renderer.
- **Directory layout** follows electron-vite convention: `src/main/`, `src/preload/`, `src/renderer/`. The renderer bundles from `src/renderer/index.html`.
- **Preload script** at `src/preload/index.ts` — exposes `window.api` via `contextBridge`. The renderer never imports electron directly.
- **electron** is a devDependency, not a regular dependency.
- **Wayland errors** on launch (`Incomplete image description info from compositor`, `UnitExists`) are benign compositor quirks — not app bugs.
- **Module system**: Using ESNext modules with bundler resolution (electron-vite handles CJS/ESM translation for Electron main process).
- **tsconfig split**: `tsconfig.json` (base), `tsconfig.node.json` (main+preload — no DOM), `tsconfig.web.json` (renderer — DOM libs).
- **Zod v4** (`^4.3.6`): `z.discriminatedUnion('type', [...])` works. `z.int()` exists for integer validation. `z.tuple()` for fixed-length arrays. `safeParse` returns `{ success, data, error }` as before.
- **Rig schema design**: `PartSchema.mesh` has a nested `deformers` field in the JSON fixture but the schema puts `deformers` on `PartSchema` directly. The `mesh.deformers` in the fixture is stripped (Zod strips unknown keys). Both schemas and cross-field validation live in a single `rig.ts` file.
- **Test fixture** at `test/fixtures/test-rig.json`: 2 parts (face, eye_left), 1 warp deformer (squeeze_center on face), 1 rotate deformer (on eye_left), 2 parameters (head_angle_x, eye_open_left), 1 physics entry (pendulum on face).
- **PixiJS v8** (`8.16.0`): `Application` uses async `init()` method. `MeshGeometry` takes `{ positions, uvs, indices }` options object (Float32Array/Uint32Array). `Mesh` takes `{ geometry, texture }` options. Setting `geometry.positions = newFloat32Array` updates the buffer. `Texture.WHITE` is the built-in white texture fallback. `Assets.load()` is the async texture loader.
- **Renderer architecture**: `RigRenderer` class owns a `PIXI.Application` + root `Container`. Each rig part maps to a `PartState` holding the PIXI Mesh, geometry, base positions (immutable), and deformer instances. Deformations are recomputed from base positions on every param change (no incremental updates).
- **Camera controls**: Pan via middle-mouse or Ctrl+left-click drag. Zoom via scroll wheel toward cursor (adjusts root container position + scale). All implemented in `setupCameraControls()`.
- **Part selection**: Uses PIXI's built-in `eventMode: 'static'` + pointer events. Wireframe overlay drawn with `Graphics.setStrokeStyle()` + `moveTo/lineTo/closePath/stroke`. Selection overlay is a separate Graphics child on the root container.
- **Manual test in main.ts**: The renderer entry point (`src/renderer/main.ts`) loads an inline copy of the test rig with `Texture.WHITE` fallback and creates interactive sliders in the param panel. Run `npm run dev` to visually verify.
- **Pre-existing TS error** in `deformer.test.ts` line 84 (3 args instead of 1-2 for `expect.toBeCloseTo`) — shows under `tsc --noEmit` but Vitest still runs it successfully. Non-blocking.
- **EventBus** is a generic `EventBus<T extends Record<string, unknown>>` class in `src/renderer/ui/events.ts`. `AppEvents` type and `AppState` class live in the same file. `AppState` auto-populates parameter defaults from the rig on `setRig()` and emits `rigLoaded`, `paramChanged`, `partSelected` events on mutations.
- **IPC architecture** (Task 6): Main process registers handlers in `src/main/ipc.ts` for `dialog:openFile`, `dialog:saveFile`, `fs:readFile`, `fs:writeFile`, `fs:readDir`. Preload script (`src/preload/index.ts`) exposes these plus `onMenuAction` via `contextBridge`. Renderer types declared in `src/renderer/env.d.ts` (self-contained, doesn't import from preload because tsconfigs are split). Menu actions flow: native `Menu` click → `mainWindow.webContents.send('menu:action', action)` → renderer `window.api.onMenuAction(callback)`.
- **`fs:readFile` returns `ArrayBuffer`** (not `Buffer`) — the main process slices the Node Buffer's underlying ArrayBuffer to avoid structured-clone issues across IPC.
- **MediaPipe tasks-vision** (`@mediapipe/tasks-vision`): WASM runtime ships with the npm package. Models are loaded from Google storage CDN by default. `FilesetResolver.forVisionTasks(basePath)` initialises WASM, then `FaceLandmarker.createFromOptions()` / `PoseLandmarker.createFromOptions()` creates the detector. Both use `runningMode: 'IMAGE'` and `.detect(imageData)`.
- **Keypoint detection** (`src/renderer/ai/keypoint.ts`): exports `detectFaceLandmarks`, `detectBodyJoints`, `estimateKeypointsHeuristic`, and `detectKeypoints` (orchestrator). All return `KeypointMap = Record<string, [number, number]>` with pixel coordinates. Standard keypoint names: `face_center`, `eye_left`, `eye_right`, `mouth_center`, `nose_tip`, `ear_left`, `ear_right`, `shoulder_left`, `shoulder_right`, `elbow_left`, `elbow_right`, `wrist_left`, `wrist_right`, `torso_center`.
- **Heuristic bounding box** uses alpha channel scan. Pixel-based bbox means `bw = maxX - minX` (not `w` from the fill rect), which is off-by-one from the fill width. Tests account for this.
- **MediaPipe FaceLandmarker** returns 478 face mesh landmarks (normalized 0-1). Key indices: noseTip=1, leftEyeInner=133, leftEyeOuter=33, rightEyeInner=362, rightEyeOuter=263, mouthUpper=13, mouthLower=14, leftEar=234, rightEar=454, forehead=10, chin=152.
- **MediaPipe PoseLandmarker** returns 33 body landmarks (normalized 0-1). Key indices: nose=0, leftShoulder=11, rightShoulder=12, leftElbow=13, rightElbow=14, leftWrist=15, rightWrist=16, leftHip=23, rightHip=24.
- **SAM ONNX architecture**: `onnxruntime-node` requires Node.js, so ONNX inference runs in the main process via IPC (`src/main/sam-ipc.ts`). The renderer's `segmenter.ts` handles image preprocessing (OffscreenCanvas resize, CHW float conversion), mask post-processing, and overlap resolution (all pure JS). IPC channels: `sam:loadModel`, `sam:encode`, `sam:decode`, `sam:unloadModel`, `image:writeRgbaPng`. Session state (encoder/decoder `InferenceSession`) is stored in a `Map` in the main process, referenced by session ID strings.
- **SAM model details**: Encoder input is `[1, 3, 1024, 1024]` float tensor (RGB, CHW, normalized 0-1). Encoder output is `image_embeddings` `[1, 256, 64, 64]`. Decoder inputs: `image_embeddings`, `point_coords [1, N, 2]`, `point_labels [1, N]`, `mask_input [1, 1, 256, 256]`, `has_mask_input [1]`, `orig_im_size [2]`. Decoder outputs: `masks [1, numMasks, 256, 256]` (logits, threshold at 0), `iou_predictions [1, numMasks]`.
- **Float32Array.buffer typing**: In strict TS, `Float32Array.buffer` returns `ArrayBufferLike` (= `ArrayBuffer | SharedArrayBuffer`). To pass across IPC (which needs plain `ArrayBuffer`), copy via `new ArrayBuffer(size)` + `new Float32Array(buf).set(data)`.
- **SAM part priority**: eye_left > eye_right > mouth > nose > ear_left > ear_right > face > hair > arm_upper_left > arm_upper_right > body. Overlap resolution assigns contested pixels to highest-priority part.
- **ImageData in Node tests**: `ImageData` constructor doesn't exist in Node.js. Production code uses `createImageData()` helper that falls back to a plain `{ data, width, height, colorSpace }` object when `ImageData` is undefined. Tests create ImageData-like objects the same way (see `keypoint.test.ts`, `segmenter.test.ts`).
- **SAM model filenames**: The actual files from HuggingFace are named `sam_vit_b_01ec64.encoder.onnx` and `sam_vit_b_01ec64.decoder.onnx` (from a zip). The `loadSAMModel` function takes paths as arguments, not hardcoded filenames.
- **SAM encoder input name**: The ONNX model uses `input_image` as the encoder input tensor name (not `x` or `images`). Verify against actual model if issues arise.
- **Delaunator v5** (`delaunator@^5.0.1`): ESM-only. `Delaunator.from(points)` or `new Delaunator(flatCoords)`. Output: `triangles` is a `Uint32Array` of vertex indices (every 3 = one triangle). Installed `@types/delaunator` as devDep for TS declarations.
- **Auto-rig pipeline** (`autoRig.ts`): `autoRig()` returns `{ rig, idleClip }` — the `Rig` object and a separate `AnimationClip` for idle animation. The `AnimationClip`/`AnimTrack`/`AnimKeyframe` types are defined locally in `autoRig.ts` since `player.ts` (Task 17) doesn't exist yet. When Task 17 is implemented, these types should be canonical — either move them to `player.ts` or keep them in `autoRig.ts` and import from there.
- **RIG_RULES** is a `Record<string, RigRule>` constant with 10 rules. Each rule specifies `affects` (part name patterns), `deformer` type (`warp`|`rotate`), `range` [min, max], `origin` (keypoint name), optional `warpAxis`/`warpMode`, `childrenFollow`, and `autoAnimate` settings.
- **buildHierarchy** uses regex-based `PARENT_RULES` (ordered array of `[childPattern, parentPattern]`). Parts matching no rule become root children. Head is auto-created as a root child if face/eye/mouth/nose parts exist.
- **Float32Array strict typing**: `WarpDeformerImpl.apply()` and `RotateDeformerImpl.apply()` return `Float32Array<ArrayBufferLike>` in strict TS. Cast with `as Float32Array` when assigning to variables typed as `Float32Array`.
- **generateKeyframes** imports `WarpDeformerImpl`/`RotateDeformerImpl` directly from `deformer.ts` and applies deformations at min/default/max param values. Returns `KeyframeData[]` with `{ paramId, values: { atMin, atDefault, atMax } }` per part.
- **generateIdle** creates a 6s looping clip. Breathing: 3s sine period. Head sway: 6s sine, 10% amplitude range. Auto-blink: two blinks at ~2s and ~5s, each 0.15s duration. Only generates tracks for parameters that actually exist in the rig.
- **Mesh generation pipeline** (`meshGen.ts`): `extractContour` uses Moore neighbor tracing (8-connected boundary walk, not pure marching squares — more robust for raster masks). `simplifyContour` is recursive Douglas-Peucker. `sampleInterior` uses stratified jittered sampling with grid-accelerated collision (not full Bridson's algorithm — simpler, deterministic via seeded LCG). `computeUVs` returns `[number, number][]` (not `Float32Array` as originally spec'd) to match the `Mesh.uvs` type from `rig.ts`. `validateMesh` checks vertex count 50–500, aspect ratio ≤ 10, and UV bounds. `generateMesh` auto-retries up to 3 times, adjusting density if vertex count is out of range.
- **Physics engine** (`physics.ts`): `PhysicsChain` uses Verlet integration with `Float64Array` for positions/oldPositions. Constructor takes `(anchor, length, segments, damping, gravity)` — initializes chain as vertical line hanging from anchor. `update(dt, anchorPos)` pins anchor, integrates with damping, runs 5 constraint iterations. `constrain(i, j)` is standard Verlet distance constraint that never moves point 0 (anchor). `getAngle()` returns degrees via `atan2(dx, dy)` — 0 for vertical, positive for right swing. `PhysicsEngine` manages multiple `PhysicsChainBinding` instances, `step(dt, getAnchorPos)` takes a callback to resolve anchor positions per target part and returns `Record<string, number>` of parameter values.
- **UI Layout Shell** (`src/renderer/ui/app.ts`): `initApp(container)` is the single entry point — creates the EventBus, AppState, DOM structure (toolbar, part-tree, viewport, param-panel, timeline), RigRenderer, and all wiring. Returns `{ bus, state, renderer }`. `main.ts` is now just `initApp(document.getElementById('app')!)`. The HTML `index.html` has only a bare `<div id="app">`.
- **Resizable panels**: Drag handles on panel borders update `grid-template-columns` / `grid-template-rows`. Sizes persist in `localStorage` (`panel-cols`, `panel-rows`). Min side panel width: 140px, min timeline height: 80px.
- **RigRenderer.loadImagePreview(path)**: Added to `renderer.ts` — loads a single image as a PIXI Sprite for previewing before auto-rig. Clears any existing rig/parts first.
- **Toolbar buttons**: Open Image, Auto Rig, Save Rig, Play Idle, Export. Play Idle and Export are placeholder stubs (Tasks 17 and 18). Menu actions from Electron's native `Menu` are forwarded to the corresponding toolbar buttons via `onMenuAction`.
- **Auto Rig flow**: Toolbar → `autoRig(imagePath)` → `state.setRig(rig)` → EventBus `rigLoaded` → `renderer.loadRig()`. Loading indicator shown during async pipeline. Errors displayed via `alert()`.
